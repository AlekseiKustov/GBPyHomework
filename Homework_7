#1. Реализовать класс Matrix (матрица).
# Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
#Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#Примеры матриц вы найдете в методичке.
#Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
#Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
#Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:
    @staticmethod
    def check_list(list):
        ln = [len(el) for el in list]
        return True if len(set(ln)) <= 1 else False

    def __init__(self, elements_list):
        if not Matrix.check_list(elements_list):
            raise Exeption("Переданный список невозможно приобразовать в матрицу")
        self.__matrix = elements_list

    def __str__(self):
        matrix_str = ''
        for line in self.__matrix:
            for el in line:
                matrix_str = matrix_str + '\t' + str(el)
            matrix_str = matrix_str + '\n'
        return matrix_str

    def __add__(self, other):
        if type(other) is not Matrix:
            raise Exeption('Недоступный тип слагаемого')
        res_mat = []
        for line1, line2 in zip(self.__matrix, other.__matrix):
            new_line = [a + b for a, b in zip(line1, line2)]
            res_mat.append(new_line)
        return Matrix(res_mat)

test_list = [[4, 32,3], [6, 6, 6], [4, 4, 5], [1, 1, 1]]
test_list2 = [[8, 6, 7], [8, 0, 3], [1, 2, 3], [0, 0, 0]]
c = Matrix(test_list)
print(c)
d = Matrix(test_list2)
print(d)
c = c + d
print('Сумма матриц: \n', c )


#2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
#Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3).
# Проверить работу этих методов на реальных данных.
#Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.


from abc import ABC, abstractmethod


class Habiliment(ABC):
    def __init__(self, value):
        self.__name = value

    @property
    def name(self):
        return self.__name

    @abstractmethod
    def fabric_consumption(self):
        pass


class Coat(Habiliment):
    def __init__(self, name, size):
        super().__init__(name)
        self.__size = size

    def fabric_consumption(self):
        return self.__size / 6.5 + 0.5

class Costume(Habiliment):
    def __init__(self, name, height):
        super().__init__(name)
        self.__height = height

    def fabric_consumption(self):
        return self.__height * 2 + 0.3

def print_consumption(hab):
    print(f'Расход ткани на {hab.name} составляет {hab.fabric_consumption()}')


c = Coat('пальто1', 50)
d = Costume('костюм1', 150)
print_consumption(c)
print_consumption(d)


#3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.
#Сложение. Объединение двух клеток.
# При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
#Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
#Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.


class Cell:
    def __init__(self, alveolus):
        if type(alveolus) is not int:
            raise ValueError
        if alveolus <= 0:
            raise ValueError('Количество ячеек вклетке должно быть больше 0')
        self.alveolus_count = alveolus

    def __add__(self, other):
        if type(other) is not Cell:
            raise ValueError

        return Cell(self.alveolus_count + other.alveolus_count)


    def __mul__(self, other):
        if type(other) is not Cell:
            raise ValueError

        return Cell(self.alveolus_count * other.alveolus_count)


    def __truediv__(self, other):
        if type(other) is not Cell:
            raise ValueError
        new_al_count = self.alveolus_count // other.alveolus_count
        if new_al_count == 0:
            raise ValueError('В результате деления ячеек не осталось')

        return Cell(new_al_count)

    def __sub__(self, other):
        if type(other) is not Cell:
            raise ValueError
        new_al_count = self.alveolus_count - other.alveolus_count
        if new_al_count <= 0:
            raise ValueError('После вычитания ячеек не осталось')

        return Cell(new_al_count)

    def make_order(self, row):
        num = self.alveolus_count
        result = ''
        while num > row:
            result = result + '*' * row + '\n'
            num -= row
        result = result + '*' * num

        return result

c = Cell(20)
print(c.make_order(30))
d = Cell(70)
print(d.make_order(4))
k = Cell(11)
a = d - c + k
print(a.make_order(5))
print(a.alveolus_count)
a = d * c
print(a.alveolus_count)
a = a / k
print(a.alveolus_count)
